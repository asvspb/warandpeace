version: '3.8'

services:
  wg-client:
    image: linuxserver/wireguard:latest
    container_name: wg-client
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun:/dev/net/tun
    sysctls:
      - net.ipv4.conf.all.src_valid_mark=1
    volumes:
      # Том /lib/modules нужен, только если модуль WireGuard не загружен на хосте
      - /lib/modules:/lib/modules:ro
      - ./config/wireguard:/config
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Moscow
    restart: unless-stopped
    ports:
      - "${METRICS_PORT:-9090}:8000" # Пробрасываем порт метрик бота
    healthcheck:
      test:
        - CMD-SHELL
        - |
          v=$$(wg show wg0 latest-handshakes | awk '{print $$2}')
          [ -n "$$v" ] && [ $$(( $$(date +%s) - $$v )) -lt 180 ]
      interval: 30s
      timeout: 3s
      retries: 3
    # Optional watchdog sidecar (disabled by default). Uncomment 'watchdog' service below.

  telegram-bot:
    build: .
    container_name: warandpeace-bot
    command: bash -lc "./scripts/sys/wait-for-net.sh --timeout 30 api.telegram.org api.ipify.org www.warandpeace.ru && python3 src/bot.py"
    network_mode: "service:wg-client"
    env_file:
      - .env
    environment:
      - TZ=${TZ:-Europe/Moscow}
      - METRICS_ENABLED=${METRICS_ENABLED:-true}
      - METRICS_PORT=${METRICS_PORT:-8000}
    volumes:
      - ./database:/app/database
      - ./backups:/var/backups/warandpeace
    restart: unless-stopped
    depends_on: # Примечание: в Compose v3 это не ждет healthcheck, только запускает контейнеры в нужном порядке.
      - wg-client

  watchdog:
    image: docker:cli
    container_name: wg-watchdog
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./scripts/wireguard/wg_watchdog.sh:/usr/local/bin/wg_watchdog.sh:ro
      - ./logs:/logs
    env_file:
      - .env
    environment:
      - WG_CONTAINER=${WG_CONTAINER:-wg-client}
      - WG_WATCHDOG_POLL=${WG_WATCHDOG_POLL:-30}
      - WG_UNHEALTHY_THRESHOLD=${WG_UNHEALTHY_THRESHOLD:-7}
      - WG_DISABLE_MINUTES=${WG_DISABLE_MINUTES:-15}
    restart: unless-stopped
    entrypoint: ["/bin/sh","-lc","wg_watchdog.sh"]


  web:
    build: .
    command: uvicorn src.webapp.server:app --host 0.0.0.0 --port 8080
    env_file: .env
    environment:
      - TZ=${TZ:-Europe/Moscow}
      - WEB_ENABLED=true
      - WEB_PORT=8080
      - WEB_AUTH_MODE=${WEB_AUTH_MODE:-basic}
      - WEB_RP_ID=${WEB_RP_ID}
      - WEB_RP_NAME=${WEB_RP_NAME}
      - WEB_SESSION_SECRET=${WEB_SESSION_SECRET}
      - WEB_API_ENABLED=${WEB_API_ENABLED:-false}
      - WEB_API_KEY=${WEB_API_KEY}
    volumes:
      - ./database:/app/database:ro
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-fsS", "http://localhost:8080/healthz"]
      interval: 30s
      timeout: 3s
      retries: 3

  caddy:
    image: caddy:2-alpine
    container_name: wp-caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      - CADDY_DOMAIN=${CADDY_DOMAIN}
      - CADDY_EMAIL=${CADDY_EMAIL}
    volumes:
      - ./Caddyfile:/etc/caddy/Caddyfile:ro
    depends_on:
      - web

  cron:
    build: .
    # Команда `cron -f` запускает cron в foreground-режиме, что необходимо для Docker.
    # `&& tail -f /var/log/cron.log` позволяет видеть логи крона через `docker-compose logs`.
    command: >
      bash -c "
        echo '${BACKUP_CRON:-0 3 * * *} python3 /app/tools/backup.py --component db --backend local >> /var/log/cron.log 2>&1' > /etc/cron.d/backup-cron &&
        chmod 0644 /etc/cron.d/backup-cron &&
        touch /var/log/cron.log &&
        cron -f & tail -f /var/log/cron.log
      "
    env_file:
      - .env
    environment:
      - TZ=${TZ:-Europe/Moscow}
    volumes:
      - ./database:/app/database:ro
      - ./backups:/var/backups/warandpeace
    restart: unless-stopped
