## План: состояние ключей API в базе и принятие решений без внешних проверок

Цель: хранить историю здоровья ключей (Gemini/Mistral) и принимать решение о выборе ключа мгновенно.

### 1) Модель данных
- Таблица `api_keys(id, provider, key_hash, last_ok_at, last_fail_at, fail_reason, quota_left, priority)`.
- Таблица `api_key_events(id, api_key_id, ts, ok, latency_ms, error)`.

### 2) Алгоритм
- При каждом вызове — записывать событие, обновлять агрегаты в `api_keys`.
- Выбор ключа: сортировка по `priority`, затем по `last_ok_at` и `quota_left`.
- Ротация без пробных запросов: брать следующий «здоровый» ключ.

### 3) Реализация
- [ ] Обертки провайдеров обновить для записи событий.
- [ ] CLI: `keys:status` — вывод агрегатов; `keys:disable <hash>` — ручная пометка.
- [ ] UI (веб): страница состояния ключей.

### 4) Тест-план
- Имитация 429/400 → запись в БД, исключение ключа из выбора.

### 5) Риски
- Утечки ключей — хранить только хэши/метаданные, сам ключ в `.env`.