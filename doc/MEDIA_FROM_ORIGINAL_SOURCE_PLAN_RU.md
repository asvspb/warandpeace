Последнее обновление: 2025-08-16
Статус: ready

## План: извлечение медиа с оригинального источника новости

Цель: при наличии в статье ссылки на оригинал — переходить на исходный ресурс и извлекать медиа (изображения/видео/превью) для использования в Telegram‑постах и веб‑интерфейсе.

### 1) Область и ограничения
- Извлекаем легально доступные публичные медиа по ссылкам открытого доступа.
- Соблюдаем robots.txt и условия использования (минимум — уважать `Disallow` и не превышать rate‑limit).
- Telegram ограничения: фото ≤ 10 МБ, видео ≤ 50 МБ (актуальные лимиты уточнять). Групповые медиа — до 10 элементов.

### 2) Архитектура и данные
- Парсер `parser.py` уже получает `article['link']` и `published_at`. Добавить извлечение ссылки на оригинал из текста статьи (якоря вида «Источник», `rel=canonical`, «Читать далее» и т.п.).
- Фоновый воркер для загрузки медиа (чтобы не блокировать публикацию): очередь `pending_media`.
- Таблицы БД:
  - `media (id, article_id, source_url, original_url, media_url, media_type: image|video|unknown, content_type, width, height, size_bytes, sha256, status: queued|downloaded|failed, stored_path, created_at, updated_at)`
  - Индексы: `(article_id)`, `(sha256)`, `(status)`

### 3) Извлечение медиа
- HTTP‑клиент: `aiohttp`/`requests` с таймаутами и заголовками (`User-Agent`, `Accept`, `Accept-Language`).
- Стратегия поиска на странице оригинала:
  1) Open Graph/Twitter Cards: `meta[property="og:image"], meta[property="og:video"], meta[name="twitter:image"], meta[name="twitter:player"], meta[name="twitter:image:src"]`.
  2) Встраиваемые элементы: `<figure>`, `<img>`, `<video>`; учитывать lazy‑load атрибуты (`data-src`, `srcset`).
  3) Канонические/AMP‑страницы: следовать `<link rel="amphtml">` при необходимости; парсить JSON‑LD (`application/ld+json`) на предмет `image`, `video`.
- Нормализация URL: резолвить относительные, убирать трекинг‑параметры.
- Фильтрация: исключать SVG/иконки/логотипы/пиксели отслеживания (размер < 8 KB или по пути/именам).

### 4) Загрузка и хранение
- Кэш: дедупликация по SHA‑256 и `media_url`.
- Ограничения размеров: обрезать/перекодировать при необходимости (опционально, в Iteration 2).
- Хранение:
  - Локально: `/app/media/<YYYY>/<MM>/<sha>.ext` (том Docker).
  - Метаданные — в таблице `media`.

### 5) Интеграция в пайплайн публикации
- При публикации статьи:
  - Если есть успешно скачанные медиа → отправлять как `sendMediaGroup` (до 3‑5 шт. по умолчанию) или `sendPhoto`/`sendVideo` первым, затем текст.
  - Если медиа ещё в очереди — публикуем текст сразу, а по готовности медиа (опционально) — дополнение в комментарии/новым сообщением (feature flag).
- Фоновый джоб: обрабатывать `pending_media` с ретраями, троттлингом доменов (per‑host concurrency = 1).

### 6) Изменения в коде
- `src/parser.py`:
  - [ ] Добавить функцию `extract_original_link(article_html) -> Optional[str]`.
- `src/media_fetcher.py` (новый модуль):
  - [ ] `discover_media_urls(page_html, base_url) -> list[str]`
  - [ ] `download_media(url) -> MediaRecord`
  - [ ] `queue_media_for_article(article_id, original_url)`
- `src/database.py`:
  - [ ] Таблица `media` + CRUD (создание/обновление, выборка по `article_id`).
- `src/bot.py`:
  - [ ] При публикации проверять наличие медиа; отправлять с учётом лимитов Telegram.
- `src/webapp/*`:
  - [ ] На страницах статей показывать привязанные медиа (миниатюры), ссылка на оригинал.

### 7) Конфигурация
- `.env`:
  - `MEDIA_ENABLED=true|false`
  - `MEDIA_MAX_PER_POST=5`
  - `MEDIA_TOTAL_SIZE_LIMIT_MB=40`
  - `MEDIA_DOWNLOAD_TIMEOUT_SEC=10`
- `docker-compose.yml`: том для `/app/media` (чтение вебом — ro).

### 8) Тест‑план
- Юнит: парсинг OG/Twitter/meta, нормализация URL, дедупликация.
- Интеграция: end‑to‑end — статья с оригиналом → скачивание → отправка в канал (mock Telegram API).
- Негативные: 403/404/timeout, медиа > лимитов, разные форматы (webp/avif/mp4/gif).

### 9) Риски и соответствие
- Авторские права: использовать превью/миниатюры; по требованию домена — не загружать, а давать ссылку‑превью.
- Нагрузки и блокировки: соблюдение rate‑limit, per‑host throttling, backoff.

### 10) Чек‑лист внедрения
- [ ] Схема БД `media`.
- [ ] Модуль `media_fetcher` и очередь.
- [ ] Интеграция в публикацию/веб.
- [ ] Переменные окружения и том в compose.
- [ ] Тесты и прогон на выборке доменов (5–10 разных источников).

### 11) Требования и зависимости
- Языки/библиотеки: Python 3.10+; `aiohttp` или `requests`, `beautifulsoup4`/`lxml`, `sqlalchemy` (БД v3), очередь задач (`rq`/`celery`), хранилище (локальный том Docker).
- Внешние: доступ к Telegram Bot API; интернет‑доступ к источникам (в т.ч. через VPN при необходимости).
- Системные: Docker, volume для `/app/media`, переменные окружения из раздела Конфигурация.

### 12) Критерии приемки (Definition of Done)
- Для 10 тестовых статей с разными доменами: извлечено >= 1 релевантное изображение в >= 80% случаев.
- Дедупликация по SHA‑256 и URL работает: повторные загрузки не с��здают новые записи.
- Соблюдены лимиты размеров/типов; медиа корректно отправляется в Telegram как `sendPhoto`/`sendMediaGroup`.
- При недоступности оригинала публикация текста не блокируется; ретраи работают.
- Юнит‑ и интеграционные тесты проходят.

### 13) Метрики/валидация
- Успешность загрузок (%), медианное время загрузки, распределение причин ошибок (403/404/timeout/формат).
- Среднее количество медиа на пост, доля постов с группой медиа.
- Рост потребления диска (ГБ/неделя), хиты кэша.

### 14) План отката (Rollback)
- Выключить фичу флагом `MEDIA_ENABLED=false` и перезапустить сервисы.
- Очистить очередь `pending_media`; уже загруженные медиа остаются, но не используются.
- Переключение не требует удаления схемы БД; таблица `media` может быть сохранена для повторного включения.

### 15) Артефакты и документация
- Обновить `.env.example` (переменные MEDIA_*).
- Обновить `DEPLOYMENT.md` (volume `/app/media`, ограничения ресурсов).
- Обновить README/раздел о публикации медиа в боте и вебе.

### 16) Ссылки
- Telegram Bot API (sendPhoto, sendMediaGroup): https://core.telegram.org/bots/api
- Open Graph Protocol: https://ogp.me/
- Twitter Cards: https://developer.twitter.com/en/docs/twitter-for-websites/cards/overview/markup
- JSON‑LD: https://json-ld.org/
