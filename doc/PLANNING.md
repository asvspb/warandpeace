# План текущих и недавних работ

### Этап 1: Улучшение наблюдаемости (Observability)

- [ ] **Задача:** Реализовать улучшенную систему логирования и оповещений.
- [ ] **Действие:**
    - [ ] Настроить конфигурацию логирования в `src/bot.py` для снижения шума.
    - [ ] Создать модуль `src/notifications.py` с троттлингом.
    - [ ] Интегрировать глобальный обработчик ошибок в `bot.py`.
    - [ ] Добавить вызовы уведомлений в фоновые задачи.

### Этап 2: Документация

- [X] **Задача:** Улучшить и детализировать план по логированию.
- [X] **Действие:** В документ `doc/LOGGING_AND_ALERTS_RU.md` добавлены предложения по ротации логов, конфигурируемому уровню логирования и структурному логированию.

# Долгосрочный план: Миграция на архитектуру БД v3 (Не удалять до полного выполнения)

**Общая цель:** Перевести проект на масштабируемую, кросс-совместимую (SQLite/PostgreSQL) архитектуру базы данных с использованием SQLAlchemy и Alembic для управления миграциями.

### Этап 1: Подготовка и внедрение инструментов

-   [ ] **Задача:** Установить и настроить необходимые библиотеки.
-   [ ] **Действие:**
    -   [ ] Добавить `sqlalchemy`, `psycopg2-binary`, `alembic` в `requirements.txt`.
    -   [ ] Выполнить `alembic init alembic` для создания каталога миграций.
    -   [ ] Настроить `alembic.ini` для работы с SQLite и PostgreSQL.

### Этап 2: Определение новой схемы через SQLAlchemy

-   [ ] **Задача:** Описать новую структуру БД в виде SQLAlchemy-моделей.
-   [ ] **Действие:**
    -   [ ] Создать файл `src/models.py`.
    -   [ ] В `src/models.py` определить классы `Source`, `Article`, `ArticleText`, `Digest`, точно соответствующие плану v3.

### Этап 3: Создание и применение миграций

-   [ ] **Задача:** Сгенерировать и применить миграцию для создания новой схемы.
-   [ ] **Действие:**
    -   [ ] Сгенерировать первую Alembic-миграцию (`alembic revision --autogenerate -m "create_initial_v3_schema"`).
    -   [ ] В миграции добавить логику для опционального создания ENUM-типов только для PostgreSQL.
    -   [ ] Применить миграцию к пустой базе данных (`alembic upgrade head`).

### Этап 4: Миграция данных

-   [ ] **Задача:** Перенести данные из старой SQLite базы в новую.
-   [ ] **Действие:**
    -   [ ] Создать отдельный скрипт `scripts/migrate_data_to_v3.py`.
    -   [ ] В скрипте реализовать логику чтения данных из старой БД и их вставки в новую с использованием SQLAlchemy-моделей.

### Этап 5: Рефакторинг кодовой базы

-   [ ] **Задача:** Адаптировать весь код проекта для работы с новой архитектурой.
-   [ ] **Действие:**
    -   [ ] Переписать функции в `src/database.py` для работы через сессии SQLAlchemy.
    -   [ ] Заменить все прямые вызовы `sqlite3` в коде (`bot.py`, `parser.py` и т.д.) на вызовы новых функций из `src/database.py`.

### Этап 6: Тестирование и переключение

-   [ ] **Задача:** Проверить работоспособность новой системы и переключиться на нее.
-   [ ] **Действие:**
    -   [ ] Запустить все существующие и новые тесты на SQLite с новой схемой.
    -   [ ] (Опционально) Развернуть тестовый экземпляр PostgreSQL, применить миграции и запустить тесты на нем.
    -   [ ] Обновить `.env.example` и `DEPLOYMENT.md`, чтобы отразить возможность использования PostgreSQL.
    -   [ ] После успешного тестирования удалить старый код `init_db` и скрипт миграции данных.

---

# Долгосрочный план: Переход на gemini-2.5-flash

- [ ] **Задача:** После стабилизации и официального релиза модели `gemini-2.5-flash` спланировать и осуществить переход на нее.

---

# Дорожная карта развития: Архитектура идеального новостного Telegram-агрегатора (Не удалять)

Этот документ разработан как дорожная карта, которая позволит:

1.  **Оценить** текущее состояние бота по четким критериям.
2.  **Выявить** сильные и слабые стороны.
3.  **Сформировать** конкретный план развития на несколько шагов вперед.

---

### **Архитектура идеального новостного Telegram-агрегатора**

Идеальная архитектура должна быть **модульной, масштабируемой и отказоустойчивой**. Это означает, что каждый компонент системы работает независимо, и его можно улучшать или заменять, не ломая все остальное.

#### **I. Концептуальные уровни функциональности**

Разделим развитие бота на три уровня, от простого к сложному. Это и есть ваш план развития.

**Уровень 1: MVP (Минимально жизнеспособный продукт)**

-   **Цель:** Быстро запустить работающий прототип, который выполняет базовую функцию.
-   **Функционал:**
    1.  **Сбор данных:** Автоматический сбор новостей из 5-10 RSS-лент.
    2.  **Обработка:** Минимальная — извлечение заголовка, ссылки и краткого описания.
    3.  **Публикация:** Автоматический постинг в один или несколько Telegram-каналов в стандартизированном формате (Заголовок, Ссылка, Источник).
    4.  **Управление:** Простые команды для администратора (/start, /stop, /status).

**Уровень 2: Продвинутый агрегатор (Стандарт рынка)**

-   **Цель:** Создать надежный и удобный сервис, который привлекает и удерживает аудиторию.
-   **Функционал:**
    1.  **Расширенный сбор данных:** Поддержка парсинга сайтов без RSS, мониторинг других Telegram-каналов, интеграция с новостными API.
    2.  **Курирование и фильтрация:**
        -   Удаление дубликатов.
        -   Фильтрация по ключевым словам (включение/исключение).
        -   Автоматическое добавление хештегов на основе правил.
    3.  **Структурированная подача:**
        -   Поддержка медиаконтента (изображения, видео).
        -   Продвинутое форматирование, использование "каруселей" для связанных постов.
    4.  **Пользовательское взаимодействие:**
        -   Бот для пользователей с возможностью настройки тематик и источников.
        -   Создание персональных дайджестов по расписанию.
        -   Базовый поиск по опубликованным новостям.

**Уровень 3: "Золотой стандарт" (AI-платформа)**

-   **Цель:** Стать лидером ниши за счет интеллектуальных функций и глубокой персонализации.
-   **Функционал:**
    1.  **Интеллектуальная обработка:**
        -   **AI-Суммаризация:** Автоматическое создание кратких выжимок (2-3 предложения) из длинных статей.
        -   **Тематическая классификация:** Автоматическое определение темы новости (политика, спорт, IT) с помощью ML-моделей.
        -   **Анализ тональности:** Определение эмоциональной окраски новости (позитивная, негативная, нейтральная).
        -   **Группировка в сюжеты:** Алгоритмическое объединение новостей из разных источников об одном и том же событии.
    2.  **Глубокая персонализация:**
        -   Рекомендательная система: бот предлагает новости на основе истории прочтений пользователя.
        -   Персональные уведомления о "горячих" новостях по настроенным триггерам.
    3.  **Продвинутое взаимодействие:**
        -   Семантический поиск ("найди новости про запуск ракеты на Марс", а не просто по ключевым словам).
        -   Интерактивные элементы: автоматические опросы и викторины на основе новостей.
    4.  **Аналитика:** Предоставление отчетов о трендах, самых обсуждаемых темах и источниках.

#### **II. Техническая архитектура (модульная)**

Представим систему в виде независимых сервисов (микросервисов), которые общаются друг с другом.

1.  **Модуль сбора данных (Collectors)**
    -   **RSS_Collector:** Мониторит RSS-ленты.
    -   **Site_Parser:** Парсит HTML-страницы сайтов (используя, например, Scrapy/BeautifulSoup).
    -   **Telegram_Client:** Читает другие каналы через клиентский API (Telethon/Pyrogram).
    -   Технологии: Python, Node.js.
2.  **Очередь задач (Message Queue)**
    -   Собранные "сырые" данные попадают сюда. Это буфер, который не дает системе упасть при большом потоке новостей.
    -   Технологии: RabbitMQ, Redis, Kafka.
3.  **Модуль обработки и обогащения (Processors/Workers)**
    -   Берет задачи из очереди и обрабатывает их.
    -   **Deduplicator:** Проверяет новость на дубликат (по URL, заголовку).
    -   **Tagger:** Добавляет хештеги.
    -   **Categorizer:** Определяет категорию (правила или ML-модель).
    -   **Summarizer:** (Уровень 3) Делает краткую выжимку с помощью LLM (например, через API GPT) или extractive-моделей.
    -   **Enricher:** Находит и добавляет релевантные изображения.
4.  **Хранилище данных (Storage)**
    -   **Основная БД (SQL):** Хранит структурированную информацию: пользователи, их подписки, настройки, метаданные постов (ID, канал, время). Технологии: PostgreSQL, MySQL.
    -   **БД контента (NoSQL):** Хранит полный текст статей, "сырые" данные. Гибкая структура удобна для этого. Технологии: MongoDB, Elasticsearch.
    -   **Кэш:** Для быстрого доступа к часто используемым данным (настройки, последние посты). Технологии: Redis.
5.  **Основная логика (Core Logic)**
    -   **Scheduler:** Планировщик задач. Запускает сборщики по расписанию, отправляет дайджесты.
    -   **Bot API Handler:** Принимает и обрабатывает команды от пользователей в Telegram.
    -   **User Manager:** Управляет профилями пользователей, их настройками и правами.
6.  **Модуль доставки (Delivery)**
    -   **Formatter:** Форматирует текст и медиа в соответствии с правилами Telegram (Markdown, HTML, карусели).
    -   **Sender:** Отправляет готовые посты в Telegram, обрабатывая ошибки и ограничения скорости (rate limits).