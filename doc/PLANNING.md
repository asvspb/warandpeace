# Долгосрочный план: Миграция на архитектуру БД v3 (Не удалять до полного выполнения)

**Общая цель:** Перевести проект на масштабируемую, кросс-совместимую (SQLite/PostgreSQL) архитектуру базы данных с использованием SQLAlchemy и Alembic для управления миграциями.

### Этап 1: Подготовка и внедрение инструментов

-   [ ] **Задача:** Установить и настроить необходимые библиотеки.
-   [ ] **Действие:**
    -   [ ] Добавить `sqlalchemy`, `psycopg2-binary`, `alembic` в `requirements.txt`.
    -   [ ] Выполнить `alembic init alembic` для создания каталога миграций.
    -   [ ] Настроить `alembic.ini` для работы с SQLite и PostgreSQL.

### Этап 2: Определение новой схемы через SQLAlchemy

-   [ ] **Задача:** Описать новую структуру БД в виде SQLAlchemy-моделей.
-   [ ] **Действие:**
    -   [ ] Создать файл `src/models.py`.
    -   [ ] В `src/models.py` определить классы `Source`, `Article`, `ArticleText`, `Digest`, точно соответствующие плану v3.

### Этап 3: Создание и применение миграций

-   [ ] **Задача:** Сгенерировать и применить миграцию для создания новой схемы.
-   [ ] **Действие:**
    -   [ ] Сгенерировать первую Alembic-миграцию (`alembic revision --autogenerate -m "create_initial_v3_schema"`).
    -   [ ] В миграции добавить логику для опционального создания ENUM-типов только для PostgreSQL.
    -   [ ] Применить миграцию к пустой базе данных (`alembic upgrade head`).

### Этап 4: Миграция данных

-   [ ] **Задача:** Перенести данные из старой SQLite базы в новую.
-   [ ] **Действие:**
    -   [ ] Создать отдельный скрипт `scripts/migrate_data_to_v3.py`.
    -   [ ] В скрипте реализовать логику чтения данных из старой БД и их вставки в новую с использованием SQLAlchemy-моделей.

### Этап 5: Рефакторинг кодовой базы

-   [ ] **Задача:** Адаптировать весь код проекта для работы с новой архитектурой.
-   [ ] **Действие:**
    -   [ ] Переписать функции в `src/database.py` для работы через сессии SQLAlchemy.
    -   [ ] Заменить все прямые вызовы `sqlite3` в коде (`bot.py`, `parser.py` и т.д.) на вызовы новых функций из `src/database.py`.

### Этап 6: Тестирование и переключение

-   [ ] **Задача:** Проверить работоспособность новой системы и переключиться на нее.
-   [ ] **Действие:**
    -   [ ] Запустить все существующие и новые тесты на SQLite с новой схемой.
    -   [ ] (Опционально) Развернуть тестовый экземпляр PostgreSQL, применить миграции и запустить тесты на нем.
    -   [ ] Обновить `.env.example` и `DEPLOYMENT.md`, чтобы отразить возможность использования PostgreSQL.
    -   [ ] После успешного тестирования удалить старый код `init_db` и скрипт миграции данных.

---

# Долгосрочный план: Переход на gemini-2.5-flash

- [ ] **Задача:** После стабилизации и официального релиза модели `gemini-2.5-flash` спланировать и осуществить переход на нее.

---

# Агрегатор активных планов (обновлять при появлении новых документов)

Ниже перечислены детальные планы, вынесенные в отдельные файлы. При создании нового плана добавляйте сюда ссылку и краткий статус.


- [WIREGUARD_INTEGRATION_PLAN_RU.md](WIREGUARD_INTEGRATION_PLAN_RU.md)
  - Цель: интеграция WireGuard и egress через VPN.
  - Статус: черновик/готов к внедрению по шагам.
  - Ключевые шаги: сервер `wg0`, `wg-client` в Compose, killswitch, мониторинг.

- [PY311_MIGRATION_PLAN.md](PY311_MIGRATION_PLAN.md)
  - Цель: переход на Python 3.11+.
  - Статус: план составлен, ожидает начала работ.
  - Ключевые шаги: базовый образ 3.11, проверка зависимостей, тесты, релиз.


- [GEMINI_MAIN_MERGE_PLAN_RU.md](GEMINI_MAIN_MERGE_PLAN_RU.md)
  - Цель: подготовить и провести релиз Gemini‑изменений в `main`.
  - Статус: план составлен.
  - Ключевые шаги: проверки в `develop`, оформить релиз в `CHANGELOG.md`/`RELEASELOG.md`, PR в `main`, тег, пост‑релизная синхронизация.

- [POSTGRES_MIGRATION_PLAN_RU.md](POSTGRES_MIGRATION_PLAN_RU.md)
  - Цель: переход на PostgreSQL c SQLAlchemy/Alembic.
  - Статус: план составлен.

- [ARCHIVE_SYNC_AND_DASHBOARD_PLAN_RU.md](ARCHIVE_SYNC_AND_DASHBOARD_PLAN_RU.md)
  - Цель: фоновая синхронизация архива и дашборд состояния.
  - Статус: план составлен.

- [CLOUD_BACKUP_PLAN_RU.md](CLOUD_BACKUP_PLAN_RU.md)
  - Цель: резервное копирование в облако.
  - Статус: план составлен.

- [BOT_MENU_AND_DEBUG_FEATURES_PLAN_RU.md](BOT_MENU_AND_DEBUG_FEATURES_PLAN_RU.md)
  - Цель: меню бота, debug‑режим, постинг ленты.
  - Статус: план составлен.

- [API_KEYS_HEALTH_PERSISTENCE_PLAN_RU.md](API_KEYS_HEALTH_PERSISTENCE_PLAN_RU.md)
  - Цель: хранить здоровье API‑ключей и выбирать без пробных запросов.
  - Статус: план составлен.

- [SUMMARIZATION_CONTROL_AND_TAGGING_PLAN_RU.md](SUMMARIZATION_CONTROL_AND_TAGGING_PLAN_RU.md)
  - Цель: управление суммаризацией и тегирование.
  - Статус: план составлен.

- [ZETTELKASTEN_AND_RELATED_ARTICLES_PLAN_RU.md](ZETTELKASTEN_AND_RELATED_ARTICLES_PLAN_RU.md)
  - Цель: граф связей и заметок (Zettelkasten).
  - Статус: план составлен.

- [MEDIA_FROM_ORIGINAL_SOURCE_PLAN_RU.md](MEDIA_FROM_ORIGINAL_SOURCE_PLAN_RU.md)
  - Цель: извлекать медиа с оригинального источника новости и использовать их в постах/UI.
  - Статус: план составлен.

## Справочные/концептуальные документы
- [BEST_PRACTICES.md](BEST_PRACTICES.md)
- [GEMINI.md](GEMINI.md)
- [GPT5.md](GPT5.md)

# Дорожная карта развития: Архитектура идеального новостного Telegram-агрегатора (Не удалять)

Этот документ разработан как дорожная карта, которая позволит:

1.  **Оценить** текущее состояние бота по четким критериям.
2.  **Выявить** сильные и слабые стороны.
3.  **Сформировать** конкретный план развития на несколько шагов вперед.

---

### **Архитектура идеального новостного Telegram-агрегатора**

Идеальная архитектура должна быть **модульной, масштабируемой и отказоустойчивой**. Это означает, что каждый компонент системы работает независимо, и его можно улучшать или заменять, не ломая все остальное.

#### **I. Концептуальные уровни функциональности**

Разделим развитие бота на три уровня, от простого к сложному. Это и есть ваш план развития.

**Уровень 1: MVP (Минимально жизнеспособный продукт)**

-   **Цель:** Быстро запустить работающий прототип, который выполняет базовую функцию.
-   **Функционал:**
    1.  **Сбор данных:** Автоматический сбор новостей из 5-10 RSS-лент.
    2.  **Обработка:** Минимальная — извлечение заголовка, ссылки и краткого описания.
    3.  **Публикация:** Автоматический постинг в один или несколько Telegram-каналов в стандартизированном формате (Заголовок, Ссылка, Источник).
    4.  **Управление:** Простые команды для администратора (/start, /stop, /status).

**Уровень 2: Продвинутый агрегатор (Стандарт рынка)**

-   **Цель:** Создать надежный и удобный сервис, который привлекает и удерживает аудиторию.
-   **Функционал:**
    1.  **Расширенный сбор данных:** Поддержка парсинга сайтов без RSS, мониторинг других Telegram-каналов, интеграция с новостными API.
    2.  **Курирование и фильтрация:**
        -   Удаление дубликатов.
        -   Фильтрация по ключевым словам (включение/исключение).
        -   Автоматическое добавление хештегов на основе правил.
    3.  **Структурированная подача:**
        -   Поддержка медиаконтента (изображения, видео).
        -   Продвинутое форматирование, использование "каруселей" для связанных постов.
    4.  **Пользовательское взаимодействие:**
        -   Бот для пользователей с возможностью настройки тематик и источников.
        -   Создание персональных дайджестов по расписанию.
        -   Базовый поиск по опубликованным новостям.

**Уровень 3: "Золотой стандарт" (AI-платформа)**

-   **Цель:** Стать лидером ниши за счет интеллектуальных функций и глубокой персонализации.
-   **Функционал:**
    1.  **Интеллектуальная обработка:**
        -   **AI-Суммаризация:** Автоматическое создание кратких выжимок (2-3 предложения) из длинных статей.
        -   **Тематическая классификация:** Автоматическое определение темы новости (политика, спорт, IT) с помощью ML-моделей.
        -   **Анализ тональности:** Определение эмоциональной окраски новости (позитивная, негативная, нейтральная).
        -   **Группировка в сюжеты:** Алгоритмическое объединение новостей из разных источников об одном и том же событии.
    2.  **Глубокая персонализация:**
        -   Рекомендательная система: бот предлагает новости на основе истории прочтений пользователя.
        -   Персональные уведомления о "горячих" новостях по настроенным триггерам.
    3.  **Продвинутое взаимодействие:**
        -   Семантический поиск ("найди новости про запуск ракеты на Марс", а не просто по ключевым словам).
        -   Интерактивные элементы: автоматические опросы и викторины на основе новостей.
    4.  **Аналитика:** Предоставление отчетов о трендах, самых обсуждаемых темах и источниках.

#### **II. Техническая архитектура (модульная)**

Представим систему в виде независимых сервисов (микросервисов), которые общаются друг с другом.

1.  **Модуль сбора данных (Collectors)**
    -   **RSS_Collector:** Мониторит RSS-ленты.
    -   **Site_Parser:** Парсит HTML-страницы сайтов (используя, например, Scrapy/BeautifulSoup).
    -   **Telegram_Client:** Читает другие каналы через клиентский API (Telethon/Pyrogram).
    -   Технологии: Python, Node.js.
2.  **Очередь задач (Message Queue)**
    -   Собранные "сырые" данные попадают сюда. Это буфер, который не дает системе упасть при большом потоке новостей.
    -   Технологии: RabbitMQ, Redis, Kafka.
3.  **Модуль обработки и обогащения (Processors/Workers)**
    -   Берет задачи из очереди и обрабатывает их.
    -   **Deduplicator:** Проверяет новость на дубликат (по URL, заголовку).
    -   **Tagger:** Добавляет хештеги.
    -   **Categorizer:** Определяет категорию (правила или ML-модель).
    -   **Summarizer:** (Уровень 3) Делает краткую выжимку с помощью LLM (например, через API GPT) или extractive-моделей.
    -   **Enricher:** Находит и добавляет релевантные изображения.
4.  **Хранилище данных (Storage)**
    -   **Основная БД (SQL):** Хранит структурированную информацию: пользователи, их подписки, настройки, метаданные постов (ID, канал, время). Технологии: PostgreSQL, MySQL.
    -   **БД контента (NoSQL):** Хранит полный текст статей, "сырые" данные. Гибкая структура удобна для этого. Технологии: MongoDB, Elasticsearch.
    -   **Кэш:** Для быстрого доступа к часто используемым данным (настройки, последние посты). Технологии: Redis.
5.  **Основная логика (Core Logic)**
    -   **Scheduler:** Планировщик задач. Запускает сборщики по расписанию, отправляет дайджесты.
    -   **Bot API Handler:** Принимает и обрабатывает команды от пользователей в Telegram.
    -   **User Manager:** Управляет профилями пользователей, их настройками и правами.
6.  **Модуль доставки (Delivery)**
    -   **Formatter:** Форматирует текст и медиа в соответствии с правилами Telegram (Markdown, HTML, карусели).
    -   **Sender:** Отправляет готовые посты в Telegram, обрабатывая ошибки и ограничения скорости (rate limits).