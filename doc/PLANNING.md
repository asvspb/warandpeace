# План по улучшению логирования

### Проблема
Логи перегружены неинформативными сообщениями, что затрудняет отслеживание реальных проблем и полезной работы бота.

### План решения

**Этап 1: Снижение шума в логах**
- [X] **Задача:** Убрать повторяющиеся "пустые" сообщения из логов уровня INFO.
- [X] **Действие:**
    - [X] В `src/bot.py` понизить уровень логирования для сообщений "Запущена задача проверки и публикации новостей..." и "Новых статей для публикации не найдено." с INFO на DEBUG.

**Этап 2: Добавление информативных логов**
- [X] **Задача:** Добавить в логи полезную информацию о найденных и опубликованных статьях.
- [X] **Действие:**
    - [X] В `src/bot.py` перед циклом публикации добавить сбор новых статей в список `new_articles`.
    - [X] Если `new_articles` не пуст, логировать на уровне INFO количество найденных статей и примеры.
    - [X] После цикла публикации, если были опубликованы статьи, логировать на уровне INFO сводную информацию: количество опубликованных статей, общее количество кандидатов и длительность выполнения.

**Этап 3: Тестирование и проверка**
- [X] **Задача:** Убедиться, что изменения работают корректно и не сломали существующую функциональность.
- [X] **Действие:**
    - [X] Запустить тесты с помощью `pytest`.
    - [X] Проверить логи в реальном времени, чтобы убедиться, что новые сообщения появляются, а старые - нет.

# План отладки ошибки NoneType

### Проблема

В логах появилась новая, неинформативная ошибка: `ERROR - Global handler caught an exception NoneType: None`. Это происходит потому, что глобальный обработчик ошибок в `src/bot.py` не рассчитан на то, что `context.error` может быть `None`, и падает при попытке получить тип (`type(None)`).

### План решения

**Этап 1: Улучшение диагностики в обработчике ошибок**

- [X] **Задача:** Модифицировать глобальный обработчик ошибок для получения более детальной информации.
- [X] **Действие:**
    - [X] В функции `on_error` в `src/bot.py` добавить проверку: если `context.error` равен `None`, логировать более подробное сообщение, включающее объект `update`, чтобы понять источник проблемы.
    - [X] Если `context.error` не `None`, логировать исключение вместе с объектом `update` для полного контекста.

**Этап 2: Пересборка и проверка**

- [X] **Задача:** Применить исправления и собрать новые данные об ошибке.
- [X] **Действие:**
    - [X] Пересобрать Docker-образ: `docker-compose build`.
    - [X] Перезапустить контейнер: `docker-compose up -d`.
    - [X] Внимательно следить за логами (`docker logs warandpeace-bot`) на предмет появления нового, более информативного сообщения об ошибке.

---

# План решения критических ошибок

### Проблема

Бот не работает из-за двух критических ошибок в логах:
1.  **`telegram.error.TimedOut`**: Ошибка тайм-аута при обращении к API Telegram. Вероятно, вызвана сетевыми проблемами или блокировкой.
2.  **`sqlite3.OperationalError: unable to open database file`**: Фатальная ошибка, которая приводит к падению бота. Причина — некорректный путь к файлу базы данных внутри Docker-контейнера. Это, в свою очередь, вызывает вторичную ошибку `UnboundLocalError` из-за неправильной обработки исключений.

### План решения

**Этап 1: Исправление ошибок с базой данных**

- [X] **Задача:** Устранить причину падения бота, связанную с доступом к БД.
- [X] **Действие:**
    - [X] В файле `src/database.py` изменить путь к базе данных на абсолютный: `DATABASE_NAME = "/app/database/articles.db"`.
    - [X] В функции `get_db_connection` в `src/database.py` инициализировать `conn = None` перед блоком `try` для исправления `UnboundLocalError`.

**Этап 2: Пересборка и проверка**

- [X] **Задача:** Применить исправления и убедиться, что бот запускается и работает стабильно.
- [X] **Действие:**
    - [X] Пересобрать Docker-образ командой `docker-compose build`.
    - [X] Перезапустить контейнер командой `docker-compose up -d`.
    - [X] Проанализировать логи контейнера (`docker logs warandpeace-bot`) и убедиться в отсутствии ошибок, связанных с базой данных.

**Этап 3: Мониторинг и дальнейшая диагностика**

- [X] **Задача:** Убедиться в полной работоспособности и выявить возможные скрытые проблемы.
- [X] **Действие:**
    - [X] Продолжить наблюдение за логами на предмет повторения ошибки `telegram.error.TimedOut`. Если ошибка будет повторяться, это потребует отдельного расследования (проверка сетевых настроек, прокси и т.д.).

**Этап 4: Укрепление уведомлений и снижение риска ошибок форматирования**

- [X] **Задача:** Исключить ошибки парсинга Markdown/HTML при отправке админ-уведомлений и гарантировать доставку.
- [X] **Действие:**
    - [X] Отправлять админ-уведомления простым текстом без `parse_mode`, отключив парсинг сущностей. Это устраняет ошибки вида `Can't parse entities: can't find end of the entity ...`.
    - [X] Сохранить троттлинг уведомлений (по ключам событий) и параметр `ADMIN_ALERTS_COOLDOWN_SEC` для предотвращения спама.

**Этап 5: Стабилизация сетевых вызовов Telegram API в фоновой задаче**

- [X] **Задача:** Исключить падение фоновой задачи из-за тайм-аутов `get_chat` и других сетевых вызовов.
- [X] **Действие:**
    - [X] Обернуть получение данных канала (`get_chat`) в `try/except` с уведомлением и мягким фолбэком: если не удалось получить `username`, использовать значение из `TELEGRAM_CHANNEL_ID` «как есть» (оно уже может быть `@username` или числовым ID).
    - [X] По возможности кэшировать результат `get_chat` и не вызывать его на каждом запуске задачи.
    - [X] Продолжить использование тихого режима логирования для PTB/httpx/httpcore/aiohttp, чтобы в логах оставались только осмысленные сообщения.

---

# План текущих и недавних работ

### Этап 1: Улучшение наблюдаемости (Observability)

- [X] **Задача:** Реализовать улучшенную систему логирования и оповещений.
- [X] **Действие:**
    - [X] Настроить конфигурацию логирования в `src/bot.py` для снижения шума.
    - [X] Создать модуль `src/notifications.py` с троттлингом.
    - [X] Интегрировать глобальный обработчик ошибок в `bot.py`.
    - [X] Добавить вызовы уведомлений в фоновые задачи.

### Этап 2: Документация

- [X] **Задача:** Улучшить и детализировать план по логированию.
- [X] **Действие:** В документ `doc/LOGGING_AND_ALERTS_RU.md` добавлены предложения по ротации логов, конфигурируемому уровню логирования и структурному логированию.

# Долгосрочный план: Миграция на архитектуру БД v3 (Не удалять до полного выполнения)

**Общая цель:** Перевести проект на масштабируемую, кросс-совместимую (SQLite/PostgreSQL) архитектуру базы данных с использованием SQLAlchemy и Alembic для управления миграциями.

### Этап 1: Подготовка и внедрение инструментов

-   [ ] **Задача:** Установить и настроить необходимые библиотеки.
-   [ ] **Действие:**
    -   [ ] Добавить `sqlalchemy`, `psycopg2-binary`, `alembic` в `requirements.txt`.
    -   [ ] Выполнить `alembic init alembic` для создания каталога миграций.
    -   [ ] Настроить `alembic.ini` для работы с SQLite и PostgreSQL.

### Этап 2: Определение новой схемы через SQLAlchemy

-   [ ] **Задача:** Описать новую структуру БД в виде SQLAlchemy-моделей.
-   [ ] **Действие:**
    -   [ ] Создать файл `src/models.py`.
    -   [ ] В `src/models.py` определить классы `Source`, `Article`, `ArticleText`, `Digest`, точно соответствующие плану v3.

### Этап 3: Создание и применение миграций

-   [ ] **Задача:** Сгенерировать и применить миграцию для создания новой схемы.
-   [ ] **Действие:**
    -   [ ] Сгенерировать первую Alembic-миграцию (`alembic revision --autogenerate -m "create_initial_v3_schema"`).
    -   [ ] В миграции добавить логику для опционального создания ENUM-типов только для PostgreSQL.
    -   [ ] Применить миграцию к пустой базе данных (`alembic upgrade head`).

### Этап 4: Миграция данных

-   [ ] **Задача:** Перенести данные из старой SQLite базы в новую.
-   [ ] **Действие:**
    -   [ ] Создать отдельный скрипт `scripts/migrate_data_to_v3.py`.
    -   [ ] В скрипте реализовать логику чтения данных из старой БД и их вставки в новую с использованием SQLAlchemy-моделей.

### Этап 5: Рефакторинг кодовой базы

-   [ ] **Задача:** Адаптировать весь код проекта для работы с новой архитектурой.
-   [ ] **Действие:**
    -   [ ] Переписать функции в `src/database.py` для работы через сессии SQLAlchemy.
    -   [ ] Заменить все прямые вызовы `sqlite3` в коде (`bot.py`, `parser.py` и т.д.) на вызовы новых функций из `src/database.py`.

### Этап 6: Тестирование и переключение

-   [ ] **Задача:** Проверить работоспособность новой системы и переключиться на нее.
-   [ ] **Действие:**
    -   [ ] Запустить все существующие и новые тесты на SQLite с новой схемой.
    -   [ ] (Опционально) Развернуть тестовый экземпляр PostgreSQL, применить миграции и запустить тесты на нем.
    -   [ ] Обновить `.env.example` и `DEPLOYMENT.md`, чтобы отразить возможность использования PostgreSQL.
    -   [ ] После успешного тестирования удалить старый код `init_db` и скрипт миграции данных.

---

# Долгосрочный план: Переход на gemini-2.5-flash

- [ ] **Задача:** После стабилизации и официального релиза модели `gemini-2.5-flash` спланировать и осуществить переход на нее.

---

# Дорожная карта развития: Архитектура идеального новостного Telegram-агрегатора (Не удалять)

Этот документ разработан как дорожная карта, которая позволит:

1.  **Оценить** текущее состояние бота по четким критериям.
2.  **Выявить** сильные и слабые стороны.
3.  **Сформировать** конкретный план развития на несколько шагов вперед.

---

### **Архитектура идеального новостного Telegram-агрегатора**

Идеальная архитектура должна быть **модульной, масштабируемой и отказоустойчивой**. Это означает, что каждый компонент системы работает независимо, и его можно улучшать или заменять, не ломая все остальное.

#### **I. Концептуальные уровни функциональности**

Разделим развитие бота на три уровня, от простого к сложному. Это и есть ваш план развития.

**Уровень 1: MVP (Минимально жизнеспособный продукт)**

-   **Цель:** Быстро запустить работающий прототип, который выполняет базовую функцию.
-   **Функционал:**
    1.  **Сбор данных:** Автоматический сбор новостей из 5-10 RSS-лент.
    2.  **Обработка:** Минимальная — извлечение заголовка, ссылки и краткого описания.
    3.  **Публикация:** Автоматический постинг в один или несколько Telegram-каналов в стандартизированном формате (Заголовок, Ссылка, Источник).
    4.  **Управление:** Простые команды для администратора (/start, /stop, /status).

**Уровень 2: Продвинутый агрегатор (Стандарт рынка)**

-   **Цель:** Создать надежный и удобный сервис, который привлекает и удерживает аудиторию.
-   **Функционал:**
    1.  **Расширенный сбор данных:** Поддержка парсинга сайтов без RSS, мониторинг других Telegram-каналов, интеграция с новостными API.
    2.  **Курирование и фильтрация:**
        -   Удаление дубликатов.
        -   Фильтрация по ключевым словам (включение/исключение).
        -   Автоматическое добавление хештегов на основе правил.
    3.  **Структурированная подача:**
        -   Поддержка медиаконтента (изображения, видео).
        -   Продвинутое форматирование, использование "каруселей" для связанных постов.
    4.  **Пользовательское взаимодействие:**
        -   Бот для пользователей с возможностью настройки тематик и источников.
        -   Создание персональных дайджестов по расписанию.
        -   Базовый поиск по опубликованным новостям.

**Уровень 3: "Золотой стандарт" (AI-платформа)**

-   **Цель:** Стать лидером ниши за счет интеллектуальных функций и глубокой персонализации.
-   **Функционал:**
    1.  **Интеллектуальная обработка:**
        -   **AI-Суммаризация:** Автоматическое создание кратких выжимок (2-3 предложения) из длинных статей.
        -   **Тематическая классификация:** Автоматическое определение темы новости (политика, спорт, IT) с помощью ML-моделей.
        -   **Анализ тональности:** Определение эмоциональной окраски новости (позитивная, негативная, нейтральная).
        -   **Группировка в сюжеты:** Алгоритмическое объединение новостей из разных источников об одном и том же событии.
    2.  **Глубокая персонализация:**
        -   Рекомендательная система: бот предлагает новости на основе истории прочтений пользователя.
        -   Персональные уведомления о "горячих" новостях по настроенным триггерам.
    3.  **Продвинутое взаимодействие:**
        -   Семантический поиск ("найди новости про запуск ракеты на Марс", а не просто по ключевым словам).
        -   Интерактивные элементы: автоматические опросы и викторины на основе новостей.
    4.  **Аналитика:** Предоставление отчетов о трендах, самых обсуждаемых темах и источниках.

#### **II. Техническая архитектура (модульная)**

Представим систему в виде независимых сервисов (микросервисов), которые общаются друг с другом.

1.  **Модуль сбора данных (Collectors)**
    -   **RSS_Collector:** Мониторит RSS-ленты.
    -   **Site_Parser:** Парсит HTML-страницы сайтов (используя, например, Scrapy/BeautifulSoup).
    -   **Telegram_Client:** Читает другие каналы через клиентский API (Telethon/Pyrogram).
    -   Технологии: Python, Node.js.
2.  **Очередь задач (Message Queue)**
    -   Собранные "сырые" данные попадают сюда. Это буфер, который не дает системе упасть при большом потоке новостей.
    -   Технологии: RabbitMQ, Redis, Kafka.
3.  **Модуль обработки и обогащения (Processors/Workers)**
    -   Берет задачи из очереди и обрабатывает их.
    -   **Deduplicator:** Проверяет новость на дубликат (по URL, заголовку).
    -   **Tagger:** Добавляет хештеги.
    -   **Categorizer:** Определяет категорию (правила или ML-модель).
    -   **Summarizer:** (Уровень 3) Делает краткую выжимку с помощью LLM (например, через API GPT) или extractive-моделей.
    -   **Enricher:** Находит и добавляет релевантные изображения.
4.  **Хранилище данных (Storage)**
    -   **Основная БД (SQL):** Хранит структурированную информацию: пользователи, их подписки, настройки, метаданные постов (ID, канал, время). Технологии: PostgreSQL, MySQL.
    -   **БД контента (NoSQL):** Хранит полный текст статей, "сырые" данные. Гибкая структура удобна для этого. Технологии: MongoDB, Elasticsearch.
    -   **Кэш:** Для быстрого доступа к часто используемым данным (настройки, последние посты). Технологии: Redis.
5.  **Основная логика (Core Logic)**
    -   **Scheduler:** Планировщик задач. Запускает сборщики по расписанию, отправляет дайджесты.
    -   **Bot API Handler:** Принимает и обрабатывает команды от пользователей в Telegram.
    -   **User Manager:** Управляет профилями пользователей, их настройками и правами.
6.  **Модуль доставки (Delivery)**
    -   **Formatter:** Форматирует текст и медиа в соответствии с правилами Telegram (Markdown, HTML, карусели).
    -   **Sender:** Отправляет готовые посты в Telegram, обрабатывая ошибки и ограничения скорости (rate limits).