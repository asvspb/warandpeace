# План расследования: Поиск скрипта, создающего *.db и *.bak файлы в корне проекта

**Цель:** Найти скрипт или процесс, который создает файлы с расширениями `.db` и `.bak` в корневой директории проекта, и изменить его для использования предназначенных для этого директорий (`database/`, `backups/`, `temp/`).

## Шаг 0: Быстрая фиксация факта и текущего состояния

-   [x] Зафиксировать список подозрительных файлов в корне (и близких каталогах), чтобы понимать масштаб и динамику:
    ```bash
    ls -lah | egrep '\.(db|bak)(-|$)'
    git status --ignored | egrep '\.(db|bak)(-|$)'
    ```
-   [x] Проверить `.gitignore`, чтобы .db/.bak не попадали в репозиторий случайно.
-   [x] Уточнить, в каком контексте появляются файлы: локальный запуск, под Docker/Compose, во время тестов/бэкапа/восстановления.

## Шаг 1: Поиск по кодовой базе

-   [x] **Задача:** Найти все упоминания файлов `.db` и `.bak` в коде.
-   **Действие:**
    -   [x] Выполнить поиск по всему проекту (включая `src/`, `scripts/`, `tools/`, `tests/`) по регулярному выражению, охватывающему `.db`, `.bak`, шаблоны бэкапов и любые операции записи.
        Примеры паттернов: `"\\.db\\b|\\.bak\\b|backup|with_suffix\(|rename\(|open\(|tar.add\(\"sqlite.db\"\)"
    -   [x] Проанализировать найденные участки кода на предмет использования абсолютных или относительных путей и «текущей директории» (CWD), которые могут указывать на корень проекта.
    -   [x] Особо проверить места:
        - `src/database.py` — функции `get_db_connection()`, `backup_database_copy()` (формирование путей `.bak-<ts>`)
        - `tools/backup.py` и `tools/restore.py` — создание снапшотов `sqlite.db`, архивов и переименование живой БД в `.db.bak-<ts>`
        - Тесты `tests/` — использование временных БД без указания директории (например, `test_articles.db`)

## Шаг 2: Анализ скриптов резервного копирования и восстановления

-   [ ] **Задача:** Изучить логику работы скриптов, связанных с резервным копированием и восстановлением базы данных.
-   **Действие:**
    -   [ ] Внимательно прочитать код `scripts/backup_now.py`, `scripts/restore_now.py`, `tools/backup.py`, `tools/restore.py`.
    -   [ ] Обратить особое внимание на то, как формируются пути для исходных и целевых файлов. Проверить, используются ли переменные окружения или конфигурационные файлы для определения путей.
    -   [ ] Проверить корректность переименования текущей БД в бэкап (см. `tools/restore.py`, использование `Path.with_suffix(".db.bak-<ts>")`). Ожидаемое поведение — создание `.db.bak-<ts>` рядом с рабочим файлом БД, а не в корне репозитория.

## Шаг 3: Анализ конфигурационных файлов и утилит

-   [ ] **Задача:** Проверить конфигурационные файлы и утилиты, которые могут влиять на расположение файлов БД.
-   **Действие:**
    -   [ ] Проверить `docker-compose.yml` на предмет монтирования томов (volumes), которые могут "пробрасывать" файлы в корень.
    -   [ ] Проверить `alembic.ini` и скрипты миграций в `alembic/` на предмет указания путей к базам данных.
    -   [ ] Проверить `.env`/переменные окружения `DB_SQLITE_PATH`, `LOCAL_BACKUP_DIR`, `BACKUP_TMP_DIR`:
        - Локально вне Docker значение по умолчанию `/app/database/articles.db` может быть невалидно — убедиться, что локальная разработка использует относительный путь `./database/articles.db` или явный абсолютный путь в пределах проекта.

## Шаг 4: Формулирование гипотезы и плана исправления

-   [x] **Задача:** На основе полученных данных определить причину и предложить решение.
-   **Действие:**
    -   [x] Сформулировать четкую гипотезу о том, какой именно скрипт и при каких условиях создает файлы в корне.
    -   [x] Предложить конкретные изменения в коде для исправления проблемы. Например:
        - Всегда задавать директорию для временных/тестовых БД (не оставлять голое имя файла).
        - Использовать `Path(...)` и `mkdir(parents=True, exist_ok=True)` для целевых директорий `database/`, `backups/`, `temp/`.
        - Для тестов — применять `tmp_path`/`TemporaryDirectory` или директорию `database_test/` (указать путь явно).
        - Убедиться, что все переименования/бэкапы выполняются рядом с исходным файлом БД, а не в CWD.

## Шаг 5: Внесение изменений и проверка

-   [x] **Задача:** Реализовать предложенные исправления и убедиться, что проблема решена.
-   **Действие:**
    -   [x] Внести изменения в код.
    -   [x] Запустить исправленный скрипт и убедиться, что файлы создаются в правильных директориях, а в корне проекта — нет.
    -   [x] Прогнать тесты, чтобы убедиться, что изменения не сломали функциональность.

---

## Дополнительно: Конкретные наблюдения по текущему репозиторию и быстрые фиксы

-   [x] Вероятный источник `.db` в корне: `tests/test_database.py` — в `setUp` принудительно устанавливает `database.DATABASE_NAME = "test_articles.db"` (без директории), из‑за чего тестовая БД создаётся в текущей директории запуска тестов (часто — корень репозитория). Исправление:
    -   [x] Задавать путь в подкаталог: например, `database_test/test_articles.db` (убедиться, что каталог существует), либо использовать `tmp_path` фикстуру `pytest`/`TemporaryDirectory`.
-   [x] Потенциальные источники `.bak` рядом с БД:
    -   [x] `src/database.py: backup_database_copy()` — создаёт файлы `articles.db.bak-<ts>` рядом с `DATABASE_NAME`. Если `DATABASE_NAME` указывает на файл в корне (как в тестах) — бак‑файл появится там же. Решение: как выше — уводить тестовую БД в отдельную директорию.
    -   [x] `tools/restore.py` — при восстановлении переименовывает живую БД в `.db.bak-<ts>` рядом с файлом БД. Это корректно; важно лишь, чтобы рабочая БД не находилась в корне.

## Профилактика (чтобы не вернулось)

-   [x] В `tests/` стандартизовать фикстуру/утилиту для выдачи пути к временной БД (из `tmp_path`) вместо захардкоженного имени.
-   [ ] В `src/config.py` для локальной разработки (не Docker) рассмотреть дефолт `DB_SQLITE_PATH="./database/articles.db"` или явно требовать переменную окружения; задокументировать это в `DEPLOYMENT.md`.
-   [ ] Добавить в `.gitignore` правила на `*.db`, `*.bak-*`, чтобы артефакты не попадали в VCS.
-   [ ] В CI добавить проверку отсутствия новых `.db/.bak` файлов в корне после тестов:
    ```bash
    git ls-files -o --exclude-standard | egrep '\\.(db|bak)(-|$)' && { echo 'Unexpected db/bak files'; exit 1; } || true
    ```

## Критерии готовности (DoD)

-   [x] Ни один сценарий (локальный, под Docker, тесты, бэкап/восстановление) не создаёт `.db/.bak` в корне проекта.
-   [x] Все временные/тестовые БД создаются в специально отведённых директориях (`database_test/`, `temp/` или системный TMP).
-   [ ] В CI есть защита от появления артефактов `.db/.bak` в корне.